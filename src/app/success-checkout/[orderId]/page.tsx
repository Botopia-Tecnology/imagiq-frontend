"use client";

/**
 * P√°gina de confirmaci√≥n de compra exitosa
 * Muestra overlay de √©xito con animaci√≥n y mensaje de confirmaci√≥n
 * Siempre redirige al usuario a la p√°gina principal al hacer clic en "Continuar"
 *
 * Caracter√≠sticas:
 * - Animaci√≥n premium con video de confirmaci√≥n
 * - Mensaje claro y directo
 * - Limpieza autom√°tica del carrito
 * - Redirecci√≥n a la p√°gina principal para continuar comprando
 * - Dise√±o responsive y accesible
 * - Env√≠o autom√°tico de mensaje de WhatsApp con confirmaci√≥n
 */

import { useRouter } from "next/navigation";
import { use, useEffect, useRef, useState } from "react";
import CheckoutSuccessOverlay from "../../carrito/CheckoutSuccessOverlay";
import { useCart } from "@/hooks/useCart";
import { apiClient } from "@/lib/api";
import { useAnalyticsWithUser } from "@/lib/analytics";
import { apiPost } from "@/lib/api-client";
import { addBusinessDays, getNextBusinessDay } from "@/lib/dateUtils";
import useSecureStorage from "@/hooks/useSecureStorage";
import { User } from "@/types/user";

interface OrderItem {
  sku: string;
  quantity?: number;
  cantidad?: number;
  product_name?: string;
  nombre?: string;
  desdetallada?: string;
  unit_price?: string | number;
  precio?: string | number;
  imagen?: string;
  image_preview_url?: string;
  picture_url?: string;
}

interface TiendaData {
  codigo?: string;
  descripcion?: string;
  nombre?: string;
  direccion?: string;
  ciudad?: string;
  telefono?: string;
  latitud?: string;
  longitud?: string;
}

interface DireccionDestino {
  id?: string;
  linea_uno?: string;
  direccion_formateada?: string;
  ciudad?: string;
}

interface OrderData {
  id?: string;
  orden_id?: string;
  fecha_creacion: string;
  usuario_id?: string;
  metodo_envio?: number; // 1=Coordinadora, 2=Pickup, 3=Imagiq
  total_amount?: number;
  serial_id?: string;
  envios?: Array<{
    numero_guia: string;
    tiempo_entrega_estimado: string;
  }>;
  order_items?: OrderItem[];
  productos?: OrderItem[]; // Para Coordinadora
  // Para Imagiq
  envio?: {
    numero_guia: string;
    tiempo_entrega_estimado: string;
    direccion_destino?: DireccionDestino;
    tienda_origen?: TiendaData;
  };
  items?: OrderItem[]; // Para Imagiq y Pickup
  // Para Pickup
  tienda?: TiendaData;
  tienda_origen?: TiendaData;
  token?: string;
  recogida_tienda?: {
    hora_recogida_autorizada?: string;
  };
  direccion_entrega?: string;
  ciudad_entrega?: string;
  shippingAddress?: string;
}

interface UserData {
  id: string;
  nombre: string;
  apellido: string;
  telefono: string;
  email?: string;
}


export default function SuccessCheckoutPage({
  params,
}: Readonly<{ params: Promise<{ orderId: string }> }>) {
  const pathParams = use(params);
  const router = useRouter();
  const [open, setOpen] = useState(true);
  const { clearCart } = useCart();
  const { trackPurchase } = useAnalyticsWithUser();
  const whatsappSentRef = useRef(false);
  const analyticsSentRef = useRef(false);
  const emailSentRef = useRef(false);
  // Hook para obtener usuario del localStorage encriptado (para usuarios sin sesi√≥n activa pero con cuenta creada en Step2)
  const [loggedUser] = useSecureStorage<User | null>("imagiq_user", null);

  // Enviar evento de purchase a analytics
  useEffect(() => {
    const sendPurchaseEvent = async () => {
      if (analyticsSentRef.current) return;
      analyticsSentRef.current = true;

      try {
        const orderResponse = await apiClient.get<OrderData>(
          `/api/orders/shipping-info/${pathParams.orderId}`
        );

        if (orderResponse.success && orderResponse.data) {
          const orderData = orderResponse.data;
          const items = orderData.order_items || [];

          // Calcular el valor total de la orden
          const totalValue = items.reduce(
            (sum, item) => sum + (item.quantity || 0) * 1000000,
            0
          ); // Estimado

          // Enviar evento de purchase
          trackPurchase(
            pathParams.orderId,
            items.map((item) => ({
              item_id: item.sku || "unknown",
              item_name: item.product_name || "Producto",
              item_brand: "Samsung",
              price: 1000000, // Precio estimado, idealmente deber√≠a venir de la orden
              quantity: item.quantity || 1,
            })),
            totalValue
          );
        }
      } catch (error) {
        console.error("[Analytics] Error sending purchase event:", error);
      }
    };

    sendPurchaseEvent();
  }, [pathParams.orderId, trackPurchase]);

  /*
  // Enviar mensaje de WhatsApp cuando se carga la p√°gina
  useEffect(() => {
    const sendWhatsAppMessage = async () => {
      if (whatsappSentRef.current) {
        return; // Evitar env√≠os duplicados
      }
      whatsappSentRef.current = true; // Marcar como enviado inmediatamente

      try {
        // Primero obtener el m√©todo de env√≠o
        let metodoEnvio: number | undefined;
        try {
          const deliveryMethodRes = await apiClient.get<{ metodo_envio: number }>(
            `/api/orders/${pathParams.orderId}/delivery-method`
          );
          if (deliveryMethodRes.success && deliveryMethodRes.data) {
            metodoEnvio = deliveryMethodRes.data.metodo_envio;
          }
        } catch (error) {
          console.error("‚ùå [WhatsApp] Error al obtener m√©todo de env√≠o:", error);
          return;
        }

        // Validar m√©todo de env√≠o soportado (1=Coordinadora, 2=Pickup, 3=Imagiq)
        if (metodoEnvio !== 1 && metodoEnvio !== 2 && metodoEnvio !== 3) {
          console.log("‚ÑπÔ∏è [WhatsApp] WhatsApp no se env√≠a para este m√©todo de env√≠o:", {
            metodo_envio: metodoEnvio,
            ordenId: pathParams.orderId,
            razon: "M√©todo desconocido"
          });
          return;
        }

        // Obtener datos de la orden seg√∫n el m√©todo de env√≠o
        // Coordinadora (1): usar /api/orders/shipping-info/${orderId} para obtener items
        // Pickup (2): usar /api/orders/${orderId}/tiendas para obtener datos de tienda
        // Imagiq (3): usar /api/orders/${orderId}/imagiq
        let orderEndpoint = `/api/orders/shipping-info/${pathParams.orderId}`;
        if (metodoEnvio === 2) {
          orderEndpoint = `/api/orders/${pathParams.orderId}/tiendas`;
        } else if (metodoEnvio === 3) {
          orderEndpoint = `/api/orders/${pathParams.orderId}/imagiq`;
        }

        const orderResponse = await apiClient.get<OrderData>(orderEndpoint);

        if (!orderResponse.success || !orderResponse.data) {
          console.error("‚ùå [WhatsApp] Error al obtener datos de la orden:", orderResponse);
          return;
        }

        const orderData = orderResponse.data;

        // Obtener datos del usuario desde SecureStorage (datos encriptados)
        // Usamos loggedUser que viene del hook useSecureStorage
        const userInfo: UserData | null = loggedUser ? {
          id: loggedUser.id,
          nombre: loggedUser.nombre || "",
          apellido: loggedUser.apellido || "",
          telefono: loggedUser.telefono || "",
          email: loggedUser.email,
        } : null;

        if (!userInfo || !userInfo.telefono) {
          console.error("‚ùå [WhatsApp] No hay informaci√≥n de usuario o tel√©fono disponible", { loggedUser });
          return;
        }

        // Limpiar y formatear el tel√©fono (quitar espacios, guiones, par√©ntesis, etc.)
        let telefono = userInfo.telefono.toString().replace(/[\s+\-()]/g, "");

        // Asegurar que el tel√©fono tenga el c√≥digo de pa√≠s 57
        if (!telefono.startsWith("57")) {
          telefono = "57" + telefono;
        }

        // Capitalizar la primera letra del nombre
        const nombreCapitalizado =
          userInfo.nombre.charAt(0).toUpperCase() +
          userInfo.nombre.slice(1).toLowerCase();

        // CASO 1: PICKUP EN TIENDA (metodo_envio === 2)
        if (metodoEnvio === 2) {
          // Para pickup, necesitamos: nombre de tienda, nombre usuario, order id, token
          const ordenId = orderData.id || pathParams.orderId;
          
          // Obtener datos de la tienda
          const tiendaData = orderData.tienda || orderData.tienda_origen;
          let nombreTienda = tiendaData?.descripcion || tiendaData?.nombre || "Tienda IMAGIQ";
          
          // Validar y truncar nombre de tienda si excede 30 caracteres
          if (nombreTienda.length > 30) {
            // Para Bogot√°: quitar "Ses " del inicio si existe
            if (nombreTienda.toLowerCase().includes('bogot√°') || nombreTienda.toLowerCase().includes('bogota')) {
              if (nombreTienda.startsWith("Ses ")) {
                nombreTienda = nombreTienda.substring(4); // Quitar "Ses "
              }
            } else {
              // Para otras ciudades: tomar √∫ltimas 3, 2 o 1 palabra seg√∫n sea necesario
              const palabras = nombreTienda.trim().split(/\s+/); // Dividir por espacios
              
              // Intentar con las √∫ltimas 3 palabras
              if (palabras.length >= 3) {
                const ultimas3 = palabras.slice(-3).join(' ');
                if (ultimas3.length <= 30) {
                  nombreTienda = ultimas3;
                } else {
                  // Si a√∫n excede, intentar con las √∫ltimas 2 palabras
                  if (palabras.length >= 2) {
                    const ultimas2 = palabras.slice(-2).join(' ');
                    if (ultimas2.length <= 30) {
                      nombreTienda = ultimas2;
                    } else {
                      // Si a√∫n excede, tomar solo la √∫ltima palabra
                      nombreTienda = palabras[palabras.length - 1];
                    }
                  } else {
                    nombreTienda = palabras[palabras.length - 1];
                  }
                }
              } else {
                // Si hay menos de 3 palabras, tomar la √∫ltima
                nombreTienda = palabras[palabras.length - 1];
              }
            }
          }
          
          // Obtener token de recogida - puede venir como objeto o string
          const tokenData = orderData.token as unknown;
          let tokenRecogida = "";
          if (typeof tokenData === 'string') {
            tokenRecogida = tokenData;
          } else if (tokenData && typeof tokenData === 'object' && 'token' in tokenData) {
            tokenRecogida = String((tokenData as { token: string }).token);
          }
          
          // Obtener n√∫mero de pedido (serial_id o primeros 8 del UUID)
          const numeroPedido = orderData.serial_id || ordenId.substring(0, 8);

          const payloadPickup = {
            to: telefono,
            nombre: nombreCapitalizado,
            numeroPedido: numeroPedido,
            nombreTienda: nombreTienda,
            producto: "Token", // Fijo
            horarioRecogida: tokenRecogida, // Este es el token
            resumen: "Token", // Fijo
            ordenId: ordenId
          };

          console.log("üì± [WhatsApp Pickup] Payload que se enviar√°:", JSON.stringify(payloadPickup, null, 2));

          // Enviar mensaje de WhatsApp de pickup al backend
          try {
            const whatsappData = await apiPost<{
              success: boolean;
              messageId?: string;
              message?: string;
              error?: string;
              details?: string;
            }>('/api/messaging/pickup', payloadPickup);

            if (!whatsappData.success) {
              console.error("‚ùå [WhatsApp] Error en respuesta de WhatsApp pickup:", {
                success: whatsappData.success,
                error: whatsappData.error,
                details: whatsappData.details
              });
              whatsappSentRef.current = false;
            } else {
              console.log("‚úÖ [WhatsApp] Mensaje de pickup enviado exitosamente:", {
                messageId: whatsappData.messageId,
                message: whatsappData.message,
                ordenId: pathParams.orderId,
                telefono: telefono
              });
            }
          } catch (whatsappError) {
            console.error("‚ùå [WhatsApp] Error al enviar mensaje de WhatsApp pickup:", whatsappError);
            whatsappSentRef.current = false;
            return;
          }
          
          return; // Terminar aqu√≠ para pickup
        }

        // CASO 2 y 3: ENV√çO A DOMICILIO (Coordinadora o Imagiq)
        // Obtener datos del env√≠o seg√∫n el m√©todo
        let numeroGuia: string;
        let tiempoEntregaEstimado: string | undefined;

        if (metodoEnvio === 3) {
          // Imagiq: datos vienen en orderData.envio
          numeroGuia = orderData.envio?.numero_guia || 
            (orderData.orden_id ? orderData.orden_id.substring(0, 8) : pathParams.orderId.substring(0, 8));
          tiempoEntregaEstimado = orderData.envio?.tiempo_entrega_estimado;
        } else {
          // Coordinadora: datos vienen en orderData.envios array
          const envioData =
            orderData.envios && orderData.envios.length > 0
              ? orderData.envios[0]
              : null;
          numeroGuia = envioData?.numero_guia || 
            (orderData.orden_id ? orderData.orden_id.substring(0, 8) : pathParams.orderId.substring(0, 8));
          tiempoEntregaEstimado = envioData?.tiempo_entrega_estimado;
        }

        // Calcular fechas de entrega estimada (formato corto para WhatsApp) - solo d√≠as h√°biles
        let fechaEntrega = "Pr√≥ximamente";

        if (tiempoEntregaEstimado) {
          const fechaCreacion = new Date(orderData.fecha_creacion);
          const dias = Number.parseInt(tiempoEntregaEstimado);

          // Calcular fecha inicial sumando d√≠as h√°biles
          const fechaInicial = addBusinessDays(fechaCreacion, dias);
          const diaInicio = fechaInicial.getDate();
          const mesInicio = fechaInicial.toLocaleDateString("es-ES", {
            month: "short",
          });

          // Fecha final: un d√≠a h√°bil despu√©s de la inicial
          const fechaFinal = getNextBusinessDay(fechaInicial);
          const diaFin = fechaFinal.getDate();
          const mesFin = fechaFinal.toLocaleDateString("es-ES", {
            month: "short",
          });

          // Formato corto: "29-31 de oct" o "29 oct - 1 nov"
          if (mesInicio === mesFin) {
            fechaEntrega = `${diaInicio}-${diaFin} de ${mesInicio}`;
          } else {
            fechaEntrega = `${diaInicio} ${mesInicio} - ${diaFin} ${mesFin}`;
          }
        }

        // Obtener productos seg√∫n el m√©todo
        let productosDesc = "tus productos";
        let cantidadTotal = 0;

        if (metodoEnvio === 3) {
          // Imagiq: productos vienen en orderData.items
          if (orderData.items && orderData.items.length > 0) {
            cantidadTotal = orderData.items.reduce(
              (total: number, item: { cantidad?: number }) => {
                return total + (item.cantidad || 1);
              },
              0
            );

            const descripcion = orderData.items
              .map((item: { cantidad?: number; desdetallada?: string; nombre?: string }) => {
                const quantity = item.cantidad || 1;
                const name = item.desdetallada || item.nombre || "producto";
                return `${quantity} ${name}`;
              })
              .join(", ");

            // WhatsApp tiene l√≠mite de 30 caracteres para este campo
            if (descripcion.length <= 30) {
              productosDesc = descripcion;
            } else {
              productosDesc =
                cantidadTotal === 1
                  ? "tu producto"
                  : `tus ${cantidadTotal} productos`;
            }
          }
        } else {
          // Coordinadora: obtener items del carrito desde localStorage
          const cartItems = localStorage.getItem("cart-items");
          if (cartItems) {
            try {
              const items = JSON.parse(cartItems);
              if (Array.isArray(items) && items.length > 0) {
                cantidadTotal = items.reduce(
                  (total: number, item: { quantity?: number }) => {
                    return total + (item.quantity || 1);
                  },
                  0
                );

                const descripcion = items
                  .map(
                    (item: {
                      quantity?: number;
                      name?: string;
                      sku?: string;
                    }) => {
                      const quantity = item.quantity || 1;
                      const name = item.name || item.sku || "producto";
                      return `${quantity} ${name}`;
                    }
                  )
                  .join(", ");

                if (descripcion.length <= 30) {
                  productosDesc = descripcion;
                } else {
                  productosDesc =
                    cantidadTotal === 1
                      ? "tu producto"
                      : `tus ${cantidadTotal} productos`;
                }
              }
            } catch {
              // Error al parsear cart-items, continuar con valor por defecto
            }
          }
        }

        // Validar y truncar productos si excede 30 caracteres
        let productosFinal = productosDesc;
        if (productosDesc.length > 30) {
          productosFinal = "tus productos";
        }

        // Validar y truncar fechaEntrega si excede 30 caracteres
        let fechaEntregaFinal = fechaEntrega;
        if (fechaEntrega.length > 30) {
          fechaEntregaFinal = "Pr√≥ximamente";
        }

        // Preparar payload para el endpoint /api/messaging/pedido-confirmado
        // El backend maneja el template_id internamente, no necesitamos enviarlo
        // Usar el id (UUID) de la orden como orderId
        const ordenId = orderData.id || pathParams.orderId;
        
        const payload = {
          to: telefono,
          nombre: nombreCapitalizado,
          ordenId: ordenId,
          numeroGuia: numeroGuia,
          productos: productosFinal,
          fechaEntrega: fechaEntregaFinal,
        };

        // Enviar mensaje de WhatsApp al backend usando apiPost
        try {
          const whatsappData = await apiPost<{
            success: boolean;
            messageId?: string;
            message?: string;
            error?: string;
            details?: string;
          }>('/api/messaging/pedido-confirmado', payload);

          // Verificar respuesta exitosa seg√∫n la especificaci√≥n del endpoint
          if (!whatsappData.success) {
            console.error("‚ùå [WhatsApp] Error en respuesta de WhatsApp:", {
              success: whatsappData.success,
              error: whatsappData.error,
              details: whatsappData.details
            });
            whatsappSentRef.current = false;
          } else {
            console.log("‚úÖ [WhatsApp] Mensaje enviado exitosamente:", {
              messageId: whatsappData.messageId,
              message: whatsappData.message,
              ordenId: pathParams.orderId,
              telefono: telefono
            });
          }
        } catch (whatsappError) {
          console.error("‚ùå [WhatsApp] Error al enviar mensaje de WhatsApp:", whatsappError);
          // Resetear el flag para permitir reintento en caso de error
          whatsappSentRef.current = false;
          return;
        }
      } catch (error) {
        console.error("‚ùå [WhatsApp] Error al procesar env√≠o de WhatsApp:", error);
        whatsappSentRef.current = false;
      }
    };

    sendWhatsAppMessage();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [pathParams.orderId, loggedUser?.id]); // Depende del orderId y loggedUser.id, useRef previene duplicados

  // Enviar email de confirmaci√≥n cuando se carga la p√°gina
  useEffect(() => {
    const sendEmailConfirmation = async () => {
      if (emailSentRef.current) {
        return; // Evitar env√≠os duplicados
      }
      emailSentRef.current = true; // Marcar como enviado inmediatamente

      try {
        // Primero obtener el m√©todo de env√≠o
        let metodoEnvio: number | undefined;
        try {
          const deliveryMethodRes = await apiClient.get<{ metodo_envio: number }>(
            `/api/orders/${pathParams.orderId}/delivery-method`
          );
          if (deliveryMethodRes.success && deliveryMethodRes.data) {
            metodoEnvio = deliveryMethodRes.data.metodo_envio;
          }
        } catch (error) {
          console.error("‚ùå [Email] Error al obtener m√©todo de env√≠o:", error);
          return;
        }

        // Obtener datos de la orden seg√∫n el m√©todo de env√≠o
        // Para EMAIL:
        // Coordinadora (1): usar /api/orders/${orderId}/imagiq (mismo que Imagiq para obtener items)
        // Imagiq (3): usar /api/orders/${orderId}/imagiq
        // Pickup (2): usar /api/orders/${orderId}/tiendas
        let orderEndpoint = `/api/orders/${pathParams.orderId}/imagiq`;
        if (metodoEnvio === 2) {
          orderEndpoint = `/api/orders/${pathParams.orderId}/tiendas`;
        }

        const orderResponse = await apiClient.get<OrderData>(orderEndpoint);

        if (!orderResponse.success || !orderResponse.data) {
          console.error("‚ùå [Email] Error al obtener datos de la orden:", orderResponse);
          return;
        }

        const orderData = orderResponse.data;

        // Obtener datos del usuario desde SecureStorage (datos encriptados)
        // Usamos loggedUser que viene del hook useSecureStorage
        const userInfo: UserData | null = loggedUser ? {
          id: loggedUser.id,
          nombre: loggedUser.nombre || "",
          apellido: loggedUser.apellido || "",
          telefono: loggedUser.telefono || "",
          email: loggedUser.email,
        } : null;

        if (!userInfo || !userInfo.email) {
          console.error("‚ùå [Email] No hay informaci√≥n de usuario o email disponible", { loggedUser });
          return;
        }

        // Determinar si es recogida en tienda (metodo_envio === 2)
        const isRecogidaEnTienda = metodoEnvio === 2;

        if (isRecogidaEnTienda) {
          // Recogida en tienda: usar endpoint store-pickup
          // Mapear igual que en tracking service
          // Usar el id (UUID) de la orden como orderId
          const ordenId = orderData.id || pathParams.orderId;
          
          console.log("üì¶ [Email Pickup] Datos recibidos del endpoint /tiendas:", {
            ordenId,
            tienda: orderData.tienda,
            items: orderData.items,
            token: orderData.token,
            total_amount: orderData.total_amount,
            fecha_creacion: orderData.fecha_creacion
          });
          
          // Obtener datos de la tienda desde orderData (para pickup) - igual que tracking service
          const tiendaDataRaw = orderData.tienda;
          if (!tiendaDataRaw || (!tiendaDataRaw.direccion && !tiendaDataRaw.ciudad && !tiendaDataRaw.descripcion)) {
            console.error("‚ùå [Email] No hay datos de tienda para recogida");
            return;
          }

          // Mapear tienda igual que en tracking service
          const direccionTienda = (tiendaDataRaw.direccion != null && tiendaDataRaw.direccion !== "")
            ? String(tiendaDataRaw.direccion).trim()
            : "";
          const ciudadTienda = (tiendaDataRaw.ciudad != null && tiendaDataRaw.ciudad !== "")
            ? String(tiendaDataRaw.ciudad).trim()
            : "";

          const tiendaData: TiendaData = {
            nombre: (tiendaDataRaw.nombre != null && tiendaDataRaw.nombre !== "") 
              ? String(tiendaDataRaw.nombre).trim() 
              : undefined,
            descripcion: (tiendaDataRaw.descripcion != null && tiendaDataRaw.descripcion !== "") 
              ? String(tiendaDataRaw.descripcion).trim() 
              : undefined,
            direccion: direccionTienda || "Tienda IMAGIQ",
            ciudad: ciudadTienda || "Bogot√°",
            telefono: (tiendaDataRaw.telefono != null && tiendaDataRaw.telefono !== "") 
              ? String(tiendaDataRaw.telefono).trim() 
              : undefined,
          };

          // Obtener productos - igual que tracking service (data.items)
          const productos = orderData.items || [];
          const productosMapeados = productos.map((p: OrderItem) => ({
            name: p.desdetallada || p.nombre || p.product_name || p.sku || "Producto",
            quantity: p.cantidad || p.quantity || 1,
            image: p.image_preview_url || p.picture_url || undefined
          }));

          // Obtener token de recogida - puede venir como objeto o string
          const emailTokenData = orderData.token as unknown;
          let emailToken = "";
          if (typeof emailTokenData === 'string') {
            emailToken = emailTokenData;
          } else if (emailTokenData && typeof emailTokenData === 'object' && 'token' in emailTokenData) {
            emailToken = String((emailTokenData as { token: string }).token);
          }

          // Construir direcci√≥n de la tienda
          const storeAddress = tiendaData.direccion 
            ? `${tiendaData.direccion}, ${tiendaData.ciudad || ""}`.trim()
            : tiendaData.descripcion || "";

          const payload = {
            to: userInfo.email,
            orderId: ordenId,
            customerName: `${userInfo.nombre} ${userInfo.apellido || ""}`.trim(),
            products: productosMapeados,
            storeName: tiendaData.descripcion || tiendaData.nombre || "Tienda IMAGIQ",
            storeAddress: storeAddress,
            storeMapsUrl: `https://maps.google.com/?q=${encodeURIComponent(storeAddress)}`,
            pickupToken: emailToken,
            qrCodeUrl: `https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(emailToken)}`,
            orderDate: new Date(orderData.fecha_creacion).toLocaleDateString('es-ES', {
              day: 'numeric',
              month: 'long',
              year: 'numeric'
            }),
            totalValue: orderData.total_amount || 0
          };

          console.log("üìß [Email Pickup] Payload que se enviar√°:", JSON.stringify(payload, null, 2));

          try {
            const emailData = await apiPost<{
              success: boolean;
              messageId?: string;
              message?: string;
              error?: string;
              details?: string;
            }>('/api/messaging/email/store-pickup', payload);

            if (!emailData.success) {
              console.error("‚ùå [Email] Error en respuesta de email:", {
                success: emailData.success,
                error: emailData.error,
                details: emailData.details
              });
              emailSentRef.current = false;
            } else {
              console.log("‚úÖ [Email] Email de recogida enviado exitosamente:", {
                messageId: emailData.messageId,
                message: emailData.message,
                ordenId: pathParams.orderId,
                email: userInfo.email
              });
            }
          } catch (emailError) {
            console.error("‚ùå [Email] Error al enviar email de recogida:", emailError);
            emailSentRef.current = false;
          }
        } else {
          // Env√≠o a domicilio (Coordinadora o Imagiq): usar endpoint order-confirmation
          // Mapear igual que en tracking service
          // Usar el n√∫mero de gu√≠a si est√° disponible, sino el id (UUID) de la orden
          const numeroGuia = orderData.envio?.numero_guia || 
            (orderData.envios && orderData.envios.length > 0 ? orderData.envios[0].numero_guia : null);
          const ordenId = numeroGuia || orderData.id || pathParams.orderId;

          // Obtener productos - para email, Coordinadora (1) e Imagiq (3) usan el mismo endpoint /imagiq
          // Ambos devuelven data.items con desdetallada, nombre, cantidad, unit_price, image_preview_url
          const productos: OrderItem[] = orderData.items || [];

          // Mapear productos - estructura igual para Coordinadora e Imagiq cuando se usa /imagiq
          const productosMapeados = productos.map((p: OrderItem) => ({
            name: p.desdetallada || p.nombre || p.product_name || p.sku || "Producto",
            quantity: p.cantidad || p.quantity || 1,
            price: p.unit_price ? Number.parseFloat(String(p.unit_price)) : (p.precio ? Number(p.precio) : 0),
            image: p.image_preview_url || p.picture_url || p.imagen || undefined
          }));

          // Obtener direcci√≥n de env√≠o - para email, Coordinadora (1) e Imagiq (3) usan el mismo endpoint /imagiq
          // Ambos devuelven la direcci√≥n en orderData.envio.direccion_destino
          let shippingAddress = "";
          const direccionDestino = orderData.envio?.direccion_destino;
          if (direccionDestino) {
            shippingAddress = direccionDestino.direccion_formateada || 
              `${direccionDestino.linea_uno || ""}, ${direccionDestino.ciudad || ""}`.trim();
          } else {
            // Fallback si no viene en envio.direccion_destino
            shippingAddress = orderData.direccion_entrega || "";
          }

          // Calcular fecha de entrega estimada - para email, Coordinadora (1) e Imagiq (3) usan el mismo endpoint /imagiq
          // Ambos devuelven tiempo_entrega_estimado en orderData.envio
          let estimatedDelivery = "1-3 d√≠as h√°biles";
          if (orderData.envio?.tiempo_entrega_estimado) {
            const dias = Number.parseInt(orderData.envio.tiempo_entrega_estimado);
            estimatedDelivery = `${dias} d√≠a${dias > 1 ? 's' : ''} h√°bil${dias > 1 ? 'es' : ''}`;
          } else if (orderData.envios && orderData.envios.length > 0) {
            // Fallback si no viene en envio.tiempo_entrega_estimado
            const dias = Number.parseInt(orderData.envios[0].tiempo_entrega_estimado);
            estimatedDelivery = `${dias} d√≠a${dias > 1 ? 's' : ''} h√°bil${dias > 1 ? 'es' : ''}`;
          }

          // Construir URL de tracking - usar el id (UUID) para la URL, no el n√∫mero de gu√≠a
          const trackingUrlId = orderData.id || pathParams.orderId;
          const trackingUrl = `https://staging.imagiq.com/tracking-service/${trackingUrlId}`;

          const payload = {
            to: userInfo.email,
            orderId: ordenId,
            customerName: `${userInfo.nombre} ${userInfo.apellido || ""}`.trim(),
            products: productosMapeados,
            total: orderData.total_amount || 0,
            shippingAddress: shippingAddress,
            shippingMethod: metodoEnvio === 3 ? "Env√≠o Imagiq" : "Env√≠o Est√°ndar",
            estimatedDelivery: estimatedDelivery,
            trackingUrl: trackingUrl,
            orderDate: new Date(orderData.fecha_creacion).toLocaleDateString('es-ES', {
              day: 'numeric',
              month: 'long',
              year: 'numeric'
            })
          };

          try {
            const emailData = await apiPost<{
              success: boolean;
              messageId?: string;
              message?: string;
              error?: string;
              details?: string;
            }>('/api/messaging/email/order-confirmation', payload);

            if (!emailData.success) {
              console.error("‚ùå [Email] Error en respuesta de email:", {
                success: emailData.success,
                error: emailData.error,
                details: emailData.details
              });
              emailSentRef.current = false;
            } else {
              console.log("‚úÖ [Email] Email de confirmaci√≥n enviado exitosamente:", {
                messageId: emailData.messageId,
                message: emailData.message,
                ordenId: pathParams.orderId,
                email: userInfo.email
              });
            }
          } catch (emailError) {
            console.error("‚ùå [Email] Error al enviar email de confirmaci√≥n:", emailError);
            emailSentRef.current = false;
          }
        }
      } catch (error) {
        console.error("‚ùå [Email] Error al procesar env√≠o de email:", error);
        emailSentRef.current = false;
      }
    };

    sendEmailConfirmation();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [pathParams.orderId, loggedUser?.id]); // Depende del orderId y loggedUser.id, useRef previene duplicados
  */

  // Coordenadas para el efecto de expansi√≥n de la animaci√≥n (centrado)
  const [triggerPosition, setTriggerPosition] = useState(() => {
    if (typeof window !== "undefined") {
      return {
        x: window.innerWidth / 2,
        y: window.innerHeight / 2,
      };
    }
    return { x: 0, y: 0 };
  });

  /**
   * Maneja el cierre del overlay y la redirecci√≥n al tracking service
   * - Cierra suavemente la animaci√≥n
   * - Limpia el carrito de compras
   * - Redirecciona al usuario al tracking service
   */
  const handleClose = () => {
    setOpen(false);

    // Peque√±o retraso antes de redirigir para permitir que la animaci√≥n de cierre termine
    setTimeout(() => {
      // Limpiar carrito al finalizar exitosamente usando el hook centralizado
      clearCart();

      // Tambi√©n limpiar otros datos relacionados con la compra
      if (typeof window !== "undefined") {
        localStorage.removeItem("applied-discount");
        localStorage.removeItem("current-order");
        // SEGURIDAD: Limpiar datos de tarjeta temporal despu√©s de compra exitosa
        localStorage.removeItem("checkout-card-data");
      }

      // Redirigir al tracking service
      router.push(`/tracking-service/${pathParams.orderId}`);
    }, 300);
  };

  // Ajustar posici√≥n al cambiar el tama√±o de la ventana
  useEffect(() => {
    const handleResize = () => {
      setTriggerPosition({
        x: window.innerWidth / 2,
        y: window.innerHeight / 2,
      });
    };

    window.addEventListener("resize", handleResize);
    return () => window.removeEventListener("resize", handleResize);
  }, []);

  return (
    <div className="fixed inset-0 z-[9999] flex items-center justify-center bg-[#009047]">
      <CheckoutSuccessOverlay
        open={open}
        onClose={handleClose}
        message="¬°Tu compra ha sido exitosa!"
        triggerPosition={triggerPosition}
      />
    </div>
  );
}
